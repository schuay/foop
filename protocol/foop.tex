\documentclass[a4paper,10pt]{article}

\usepackage[usenames,dvipsnames]{color}
\usepackage{comment}
\usepackage[utf8]{inputenc}
\usepackage{listings}

\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\definecolor{Gray}{gray}{0.5}

\lstset{
    language=Eiffel,
    basicstyle=\ttfamily,
    keywordstyle=\color{OliveGreen},
    commentstyle=\color{Gray},
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    showspaces=false,
    showtabs=false,
    numbers=left,
}

\title{VU Fortgeschrittene Objektorientierte Programmierung \\
       SS 2013}
\author{Jakob Gruber,
        Michael Osl,
        Patrick Kohlmayr,
        Martin Lackner}

\begin{document}

\maketitle

\section{Aufgabe 3: Eiffel}

% ------------------------------------------------------------------------------

\emph{Wie hoch ist der Aufwand in Eiffel, um Zusicherungen im Programmcode zu 
formulieren?}

\vspace{3mm}

Nachdem der Syntax sehr einfach gestaltet ist, ist der Aufwand vergleichbar mit 
der Formulierung von Zusicherungen innerhalb Kommentaren. Es ist aber zu erwarten,
dass der initiale Aufwand durch eine robustere Applikation und weniger Debugging
belohnt wird.

% ------------------------------------------------------------------------------

\emph{Wie stark wirkt sich die Überprüfung von Zusicherungen auf die Laufzeit aus?}

\vspace{3mm}

Die \"Uberpr\"ufung kann zur Laufzeit beliebig eingestellt werden. M\"ogliche Optionen sind

\begin{itemize}
\item no: kein Laufzeiteffekt,
\item require: nur Preconditions,
\item ensure: zus\"atzlich Postconditions,
\item invariant: zus\"atzlich Invariants, und
\item all: Pre-, Postconditions, Invariants, Check instructions, loop (in)variants.
\end{itemize}

Man kann also je nach Bedarf die Zusicherungs\"uberpr\"ufung anpassen. Empfohlen werden
\emph{no} und \emph{require}, aber die beste Einstellung ist abh\"angig von dem am besten
geeigneten Trade-off zwischen Effizienz und Sicherheit.

\vspace{3mm}

% ------------------------------------------------------------------------------

\emph{Vorbedingungen dürfen im Untertyp nicht stärker und Nachbedingungen nicht 
schwächer werden um Ersetzbarkeit zu garantieren. Der Eiffel-Compiler überprüft 
diese Bedingungen. Ist es (trotz eingeschalteter Überprüfung von Zusicherungen) 
möglich diese Bedingungen zu umgehen? Wenn ja, wie?}

\vspace{3mm}

% TODO

\vspace{3mm}

% ------------------------------------------------------------------------------

\emph{Eiffel erlaubt kovariante Eingangsparametertypen. Unter welchen Bedingungen 
führt das zu Problemen, und wie äußern sich diese? Können Sie ein Programm 
schreiben, in dem die Verwendung kovarianter Eingangsparametertypen zu einer 
Exception führt?}

\vspace{3mm}

% TODO

\begin{comment}
See http://docs.eiffel.com/book/method/et-inheritance#Covariance.2C_anchored_declarations.2C_and_.22catcalls.22
\end{comment}

\begin{figure}
\begin{lstlisting}
local
    account: ACCOUNT
    person: PERSON
do
    create {STUDENT}person.make ("Joe")
    create {SENIOR_ACCOUNT}account.make (person)
    -- Exception
end
\end{lstlisting}
\caption{Runtime Exception ausgel\"ost durch einen catcall}
\end{figure}

\vspace{3mm}

% ------------------------------------------------------------------------------

\emph{Vereinfachen kovariante Eingangsparametertypen die Programmierung? Unter 
welchen Bedingungen ist das so?}

\vspace{3mm}

%TODO

\begin{comment}
Von OOP: Mehrfach dynamisches Binden, Multimethoden.
\end{comment}

\end{document}
