* Wie hoch ist der Aufwand in Eiffel, um Zusicherungen im Programmcode zu formulieren? 
Der Aufwand ist niedrig, da Zusicherungen in Eiffel als Sprachelement integriert sind. Dadurch kann ein Entwickler ohne weitere Zusatzbibliotheken Vor- und Nachbedingungen für Methoden, sowie Invarianten definieren.
Durch die Abgrenzung der Zusicherungen vom restlichen "funktionalen" Programmcode ist das Programm zustäzlich besser lesbar, was sich wiederum positiv auf den Wartungsaufwand auswirkt.

* Wie stark wirkt sich die Überprüfung von Zusicherungen auf die Laufzeit aus?
Das hängt stark von der Komplexität der Zusicherungen ab. In Eiffel ist es möglich in den Zusicherungsfunktionen Funktionen aufzurufen. 
So könnte zum Beispiel bei einem azyklischen Graphen, nach dem Hinzufügen eines weiteren Knotens in einer Nachbedingung zugesichert werden,
 dass der Graph noch zyklenfrei ist. Ein derartiger Funktionsaufruf kann bei größeren Graphen einige Zeit in Anspruch nehmen. 
 Anders betrachtet entspricht eine verletzte Zusicherung letztendlich einem Bug. Durch die erhöhte Laufzeit erhält man also auch ein höheres Maß an Korrektheit des Programms.


* Vorbedingungen dürfen im Untertyp nicht stärker und Nachbedingungen nicht schwächer werden um Ersetzbarkeit zu garantieren. Der Eiffel-Compiler überprüft diese Bedingungen. Ist es (trotz eingeschalteter Überprüfung von Zusicherungen) möglich diese Bedingungen zu umgehen? Wenn ja, wie? 

TODO:

* Eiffel erlaubt kovariante Eingangsparametertypen. Unter welchen Bedingungen führt das zu Problemen, und wie äußern sich diese? 
* Können Sie ein Programm schreiben, in dem die Verwendung kovarianter Eingangsparametertypen zu einer Exception führt? 
Durch das Erlauben von kovariante Eingangsparametertypen sind Subklassen nicht mehr zwangsläufig Subtypen von Basisklassen. Dadurch ist die Ersetzbarkeit nicht mehr gewährleistet. 
Dieses Problem äußert sich in Programm als Laufzeitfehler in Form einer Exception.

TODO: beispiel

* Vereinfachen kovariante Eingangsparametertypen die Programmierung? Unter welchen Bedingungen ist das so? 

TODO: anderes beispiel hernehmen (hab ich im internet gefunden).

Für manche real-world Szenarien sind kovariante Eingangsparametertypen wünschenswert. Angenommen es existiert die Klasse "Person" und eine Klasse
"Arzt". Die Klasse "Arzt" definiert außerdem die Methode "Arzt.untersuche(Person person)". Nun fügt man "Kind" als Subklasse von
"Person" und "Kinderarzt" als Subklasse von "Arzt" hinzu. Da Kinderärzte nur Kinder untersuchen würde man sich für die Methode
"Kinderarzt.untersuche(Person person)" folgende Methodensignatur wünschen: "Kinderarzt.untersuche(Kind kind)". Das ist in Eiffel durch kovariante
Eingangsparameter möglich.

oder:

1) STUDENT_ACCOUNT cast zu ACCOUNT.
2) set_signatory( instanz von ACCOUNT oder RETIREE_ACCOUNT )
3) tmp: STUDENT_ACCOUNT := STUDENT_ACCOUNT.signatory
4) aufruf einer methode in tmp die in ACCOUNT nicht existiert => SegFault